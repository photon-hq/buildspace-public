name: 'Generate Release Info'
description: 'Generate version number and release notes using AI'

inputs:
  service-name:
    description: '[string] The name of the service (used in release notes)'
    required: true
  prerelease:
    description: "[boolean: 'true'/'false'] Whether this is a prerelease (appends -rc.N suffix)"
    required: false
    default: 'false'
  openai-api-key:
    description: '[string] OpenAI API key for AI-powered version detection and notes'
    required: true

outputs:
  version:
    description: 'The determined version (e.g., 1.2.3 or 1.2.3-rc.5)'
    value: ${{ steps.version.outputs.final }}
  release_notes:
    description: 'AI-generated release notes in markdown'
    value: ${{ steps.ai-notes.outputs.final-message }}

runs:
  using: 'composite'
  steps:
    - name: Get last release info
      id: last-release
      uses: actions/github-script@v7
      with:
        script: |
          try {
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 1
            });
            
            if (releases.length > 0) {
              const tagName = releases[0].tag_name;
              const { data: ref } = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tagName}`
              });
              core.setOutput('sha', ref.object.sha);
              core.setOutput('version', tagName.replace(/^v/, ''));
            } else {
              const allCommits = await github.paginate(github.rest.repos.listCommits, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              core.setOutput('sha', allCommits[allCommits.length - 1].sha);
              core.setOutput('version', '0.0.0');
            }
          } catch (error) {
            core.setOutput('sha', context.sha);
            core.setOutput('version', '0.0.0');
          }

    - name: AI Determine Version
      id: ai-version
      uses: openai/codex-action@v1
      with:
        openai-api-key: ${{ inputs.openai-api-key }}
        safety-strategy: read-only
        prompt: |
          Analyze commits between ${{ steps.last-release.outputs.sha }} and ${{ github.sha }}.
          Current version: ${{ steps.last-release.outputs.version }}
          Prerelease: ${{ inputs.prerelease }}
          
          Rules:
          - BREAKING CHANGE or ! = major bump
          - feat: = minor bump  
          - fix:, perf:, or other = patch bump
          - Default to patch if unclear
          - For prereleases: use same version logic, suffix will be added automatically
          
          Respond with ONLY X.Y.Z

    - name: Parse Version
      id: version
      shell: bash
      run: |
        NEXT=$(echo "${{ steps.ai-version.outputs.final-message }}" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        [ -z "$NEXT" ] && { echo "::error::Invalid version"; exit 1; }
        
        if [ "${{ inputs.prerelease }}" == "true" ]; then
          echo "final=${NEXT}-rc.${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT
        else
          echo "final=${NEXT}" >> $GITHUB_OUTPUT
        fi

    - name: AI Generate Notes
      id: ai-notes
      uses: openai/codex-action@v1
      with:
        prompt: |
          Generate release notes for ${{ inputs.service-name }} v${{ steps.version.outputs.final }}.
          Changes from ${{ steps.last-release.outputs.sha }} to ${{ github.sha }}.
          
          REQUIREMENTS:
          1. NO title - start with content directly
          2. Plain language - like explaining to a friend
          3. SHORT - 1-2 sentences per item
          4. Group: ## New Features, ## Bug Fixes, ## Improvement, if they exist. For example, 
          if there are no new features, bug fixes, or improvements, don't include them.
          5. Only include breaking changes if they exist
          6. Include commit SHAs if necessary. If the commit is large, don't include it.
          7. 1-2 emojis max for personality
          8. Code diffs ONLY if necessary. If the diff is large, don't include it. 
          
          The end goal is clear business technical writing that is easy to understand, use, and bring 
          delight to the user
