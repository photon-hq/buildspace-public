name: Semantic Release with AI Notes

on:
  workflow_call:
    inputs:
      bun-version:
        type: string
        required: false
        default: "latest"
      service-name:
        type: string
        required: true
        description: "The name of the service to release"
      publish-npm:
        type: string
        required: false
        default: "false"
        description: "Whether to publish to npm"
      prerelease:
        type: string
        required: false
        default: "false"
        description: "Whether to create a prerelease"
    secrets:
      OPENAI_API_KEY:
        required: true
        description: "OpenAI API key for determining version and generating release notes"
      NPM_TOKEN:
        required: false
        description: "NPM token for publishing"

jobs:
  check-release-label:
    name: Check for Release Label
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    outputs:
      should_release: ${{ steps.check-label.outputs.has_release_label }}
    steps:
      - name: Check for release label on PR
        id: check-label
        uses: actions/github-script@v7
        with:
          script: |
            // If triggered by pull_request event, use the PR number directly
            if (context.eventName === 'pull_request') {
              const prNumber = context.payload.pull_request.number;
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              const labels = pr.labels.map(l => l.name.toLowerCase());
              
              if (labels.includes('release')) {
                console.log(`Found 'release' label on PR #${pr.number}. Proceeding with release.`);
                core.setOutput('has_release_label', 'true');
              } else {
                console.log(`No 'release' label on PR #${pr.number}. Skipping release.`);
                console.log(`Current labels: ${labels.join(', ') || 'none'}`);
                core.setOutput('has_release_label', 'false');
              }
              return;
            }
            
            // For push events, find PR for this branch
            const currentRef = context.ref;
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${currentRef.replace('refs/heads/', '')}`,
              state: 'open'
            });
            
            if (prs.length === 0) {
              console.log('No open PR found for this branch. Skipping release.');
              core.setOutput('has_release_label', 'false');
              return;
            }
            
            const pr = prs[0];
            const labels = pr.labels.map(l => l.name.toLowerCase());
            
            if (labels.includes('release')) {
              console.log(`Found 'release' label on PR #${pr.number}. Proceeding with release.`);
              core.setOutput('has_release_label', 'true');
            } else {
              console.log(`No 'release' label on PR #${pr.number}. Skipping release.`);
              console.log(`Current labels: ${labels.join(', ') || 'none'}`);
              core.setOutput('has_release_label', 'false');
            }

  analyze-and-release:
    name: Analyze Commits & Create Release
    runs-on: ubuntu-latest
    needs: check-release-label
    if: needs.check-release-label.outputs.should_release == 'true'
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ inputs.bun-version }}

      - name: Install dependencies
        run: bun install

      - name: Get latest release SHA
        id: last-release
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 1
              });
              
              if (releases.length > 0) {
                const tagName = releases[0].tag_name;
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tagName}`
                });
                core.setOutput('sha', ref.object.sha);
                core.setOutput('tag', tagName);
                core.setOutput('version', tagName.replace(/^v/, '')); // Remove 'v' prefix if present
              } else {
                // No releases exist, use initial commit
                const { data: commits } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 1,
                  sha: 'HEAD'
                });
                if (commits.length > 0) {
                  // Get the first commit (oldest)
                  const allCommits = await github.paginate(github.rest.repos.listCommits, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    per_page: 100
                  });
                  const firstCommit = allCommits[allCommits.length - 1];
                  core.setOutput('sha', firstCommit.sha);
                  core.setOutput('version', '0.0.0');
                } else {
                  core.setOutput('sha', context.sha);
                  core.setOutput('version', '0.0.0');
                }
              }
            } catch (error) {
              core.setOutput('sha', context.sha);
              core.setOutput('version', '0.0.0');
            }

      - name: Get unreleased commits
        id: commits
        run: |
          LAST_SHA="${{ steps.last-release.outputs.sha }}"
          CURRENT_SHA="${{ github.sha }}"
          
          # Write commits directly to file to avoid multiline output issues
          git log ${LAST_SHA}..${CURRENT_SHA} --pretty=format:"%s%n%b" --no-merges > /tmp/commits.txt || echo "" > /tmp/commits.txt
          
          # Set output for reference
          echo "commits_count=$(git log ${LAST_SHA}..${CURRENT_SHA} --oneline --no-merges | wc -l)" >> $GITHUB_OUTPUT

      - name: Get code diff
        id: diff
        run: |
          LAST_SHA="${{ steps.last-release.outputs.sha }}"
          CURRENT_SHA="${{ github.sha }}"
          
          # Write directly to files to avoid multiline output issues
          git diff --name-status ${LAST_SHA}..${CURRENT_SHA} > /tmp/files_changed.txt || true
          git diff --stat ${LAST_SHA}..${CURRENT_SHA} > /tmp/diff_stats.txt || true
          git diff ${LAST_SHA}..${CURRENT_SHA} -- . ':(exclude)package-lock.json' ':(exclude)bun.lock' ':(exclude)yarn.lock' ':(exclude)pnpm-lock.yaml' | head -c 50000 > /tmp/diff.txt || true
          
          # Set outputs for reference (empty if no changes)
          echo "files_changed=$(cat /tmp/files_changed.txt | wc -l)" >> $GITHUB_OUTPUT
          echo "has_changes=$(if [ -s /tmp/diff.txt ]; then echo 'true'; else echo 'false'; fi)" >> $GITHUB_OUTPUT
            
      - name: Prepare variables for AI prompts
        id: prepare-vars
        run: |
          # Write simple variables to files
          echo "${{ steps.last-release.outputs.version }}" > /tmp/current_version.txt
          echo "${{ steps.last-release.outputs.sha }}" > /tmp/last_sha.txt
          echo "${{ github.sha }}" > /tmp/current_sha.txt
          # Note: commits.txt, files_changed.txt, diff_stats.txt, and diff.txt 
          # are already written in previous steps

      - name: AI Determine new release version
        id: ai-version
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          
          # Build version prompt
          {
            echo "Analyze these git commits and code changes to determine the next semantic version number."
            echo ""
            echo "Current Version: $(cat /tmp/current_version.txt)"
            echo "Last Release SHA: $(cat /tmp/last_sha.txt)"
            echo "Current SHA: $(cat /tmp/current_sha.txt)"
            echo ""
            echo "Commit messages:"
            cat /tmp/commits.txt 2>/dev/null || echo ""
            echo ""
            echo "Files changed:"
            cat /tmp/files_changed.txt 2>/dev/null || echo ""
            echo ""
            echo "Diff stats:"
            cat /tmp/diff_stats.txt 2>/dev/null || echo ""
            echo ""
            echo "Code changes (partial):"
            cat /tmp/diff.txt 2>/dev/null || echo ""
            echo ""
            echo "Based on the actual code changes, determine what the most appropriate release type should be:"
            echo "- BREAKING CHANGE or ! in commit OR breaking API changes in code = major version bump"
            echo "- feat: prefix OR new features in code = minor version bump"
            echo "- fix: or perf: prefix OR bug fixes in code = patch version bump"
            echo "- No significant changes = no release needed"
            echo ""
            echo "X.Y.Z = the version number to release"
            echo "Where X = Major release/breaking changes"
            echo "Where Y = Minor release/new features"
            echo "Where Z = Patch release/bug fixes"
            echo "Respond with ONLY the version number in format X.Y.Z (e.g., 1.2.3) or \"none\" if no release is needed."
            echo "Do not include any other text, explanation, or markdown formatting."
          } > /tmp/version_prompt.txt
          
          # Call OpenAI API
          PROMPT=$(cat /tmp/version_prompt.txt)
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{\"role\": \"user\", \"content\": $(echo "$PROMPT" | jq -Rs .)}],
              \"temperature\": 0.3
            }")
          
          AI_RESPONSE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          echo "ai_response=$AI_RESPONSE" >> $GITHUB_OUTPUT

      - name: Parse AI version response
        id: parse-version
        run: |
          AI_RESPONSE="${{ steps.ai-version.outputs.ai_response }}"
          
          # Extract version number (X.Y.Z format) or check for "none"
          if echo "$AI_RESPONSE" | grep -qiE "none|skip|no release"; then
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "next_version=none" >> $GITHUB_OUTPUT
          else
            # Extract version number (format: X.Y.Z)
            NEXT_VERSION=$(echo "$AI_RESPONSE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            
            if [ -z "$NEXT_VERSION" ]; then
              echo "::error::AI did not return a valid version number. Response: $AI_RESPONSE"
              exit 1
            fi
            
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Apply prerelease tag
        id: final-version
        if: steps.parse-version.outputs.should_release == 'true'
        run: |
          BASE_VERSION="${{ steps.parse-version.outputs.next_version }}"
          
          if [ "${{ inputs.prerelease }}" == "true" ]; then
            # Append prerelease suffix (you can customize this)
            FINAL_VERSION="${BASE_VERSION}-rc.${GITHUB_RUN_NUMBER}"
            echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT
            echo "Creating prerelease: $FINAL_VERSION"
          else
            FINAL_VERSION="$BASE_VERSION"
            echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT
            echo "Creating release: $FINAL_VERSION"
          fi

      - name: Prepare variables for release notes
        id: prepare-notes-vars
        if: steps.parse-version.outputs.should_release == 'true'
        run: |
          printf '%s\n' "${{ steps.final-version.outputs.final_version }}" > /tmp/new_version.txt
          printf '%s\n' "${{ inputs.service-name }}" > /tmp/service_name.txt

      - name: Generate AI Release Notes
        id: ai-notes
        if: steps.parse-version.outputs.should_release == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -e
          
          # Build release notes prompt
          {
            echo "Generate release notes in markdown format. DO NOT include a title or header at the top. Start directly with the first section (e.g., ## New Features)."
            echo ""
            echo "Current Version: $(cat /tmp/current_version.txt)"
            echo "New Version: $(cat /tmp/new_version.txt)"
            echo "Last Release SHA: $(cat /tmp/last_sha.txt)"
            echo "Current SHA: $(cat /tmp/current_sha.txt)"
            echo "Service Name: $(cat /tmp/service_name.txt)"
            echo ""
            echo "Commit messages:"
            cat /tmp/commits.txt 2>/dev/null || echo ""
            echo ""
            echo "Files changed:"
            cat /tmp/files_changed.txt 2>/dev/null || echo ""
            echo ""
            echo "Diff stats:"
            cat /tmp/diff_stats.txt 2>/dev/null || echo ""
            echo ""
            echo "Code changes (partial):"
            cat /tmp/diff.txt 2>/dev/null || echo ""
            echo ""
            echo "REQUIREMENTS:"
            echo ""
            echo "1. NO title - Start directly with content"
            echo "2. Use plain language - Write like explaining to a friend (history degree, not CS)"
            echo "3. Keep it SHORT - 1-2 sentences per item max"
            echo "4. Group logically - Use headers: ## New Features, ## Bug Fixes, ## Improvements (NO emojis in headers)"
            echo "5. Only include breaking changes if they exist - Don't mention if there are none"
            echo "6. NO commit section - Don't include commit SHA or messages"
            echo "7. NO diff section - Don't show code diffs"
            echo "8. Use emojis SPARINGLY - Only use 1-2 emojis total, prefer people emojis (ðŸ™‹â€â™€ï¸ðŸ™‹â€â™‚ï¸ðŸ‘‹) over decorative ones"
            echo "9. Show personality - Be friendly and engaging like Slack's release notes"
            echo ""
            echo "Analyze commits and code changes. Create brief, organized release notes with minimal emoji usage."
          } > /tmp/notes_prompt.txt
          
          # Call OpenAI API
          PROMPT=$(cat /tmp/notes_prompt.txt)
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{\"role\": \"user\", \"content\": $(echo "$PROMPT" | jq -Rs .)}],
              \"temperature\": 0.7
            }")
          
          AI_NOTES=$(echo "$RESPONSE" | jq -r '.choices[0].message.content' || echo "")
          if [ -z "$AI_NOTES" ]; then
            echo "::error::Failed to get AI response"
            exit 1
          fi
          
          # Write to file first to avoid any shell interpretation issues
          printf '%s\n' "$AI_NOTES" > /tmp/ai_notes.txt
          
          # Use multiline output format to safely handle any special characters
          {
            echo "release_notes<<EOF"
            cat /tmp/ai_notes.txt
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Prepare release body
        id: release-body
        if: steps.parse-version.outputs.should_release == 'true'
        run: |
          # Use the AI notes file we already created, or fall back to basic format
          if [ -s /tmp/ai_notes.txt ]; then
            # Build body with AI notes
            cp /tmp/ai_notes.txt /tmp/body.txt
            echo "" >> /tmp/body.txt
            echo "---" >> /tmp/body.txt
            echo "" >> /tmp/body.txt
            echo "**Version:** ${{ steps.last-release.outputs.version }} â†’ ${{ steps.final-version.outputs.final_version }}" >> /tmp/body.txt
          else
            # Fallback: basic release notes
            echo "## Release ${{ steps.final-version.outputs.final_version }}" > /tmp/body.txt
            echo "" >> /tmp/body.txt
            echo "**Version:** ${{ steps.last-release.outputs.version }} â†’ ${{ steps.final-version.outputs.final_version }}" >> /tmp/body.txt
            echo "" >> /tmp/body.txt
            echo "### Changes" >> /tmp/body.txt
            echo "" >> /tmp/body.txt
            cat /tmp/commits.txt >> /tmp/body.txt 2>/dev/null || echo "No commits available" >> /tmp/body.txt
          fi
          
          # Write to output using multiline format
          echo "body<<BODY_EOF" >> $GITHUB_OUTPUT
          cat /tmp/body.txt >> $GITHUB_OUTPUT
          echo "BODY_EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        if: steps.parse-version.outputs.should_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.final-version.outputs.final_version }}
          name: ${{ inputs.service-name }} v${{ steps.final-version.outputs.final_version }}
          body: ${{ steps.release-body.outputs.body }}
          draft: false
          prerelease: ${{ inputs.prerelease == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish:
    name: Publish to NPM
    runs-on: ubuntu-latest
    needs: analyze-and-release
    if: inputs.publish-npm == 'true' && inputs.prerelease != 'true'
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ inputs.bun-version }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: bun install

      - name: Build
        run: bun run build

      - name: Publish to npm
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
