name: Semantic Release with AI Notes

on:
  workflow_call:
    inputs:
      bun-version:
        type: string
        required: false
        default: "latest"
      service-name:
        type: string
        required: true
        description: "The name of the service to release"
      publish-npm:
        type: string
        required: false
        default: "false"
        description: "Whether to publish to npm"
      prerelease:
        type: string
        required: false
        default: "false"
        description: "Whether to create a prerelease"
    secrets:
      OPENAI_API_KEY:
        required: true
        description: "OpenAI API key for determining version and generating release notes"
      NPM_TOKEN:
        required: false
        description: "NPM token for publishing"

jobs:
  check-release-label:
    name: Check for Release Label
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    outputs:
      should_release: ${{ steps.check-label.outputs.has_release_label }}
    steps:
      - name: Check for release label on PR
        id: check-label
        uses: actions/github-script@v7
        with:
          script: |
            // If triggered by pull_request event, use the PR number directly
            if (context.eventName === 'pull_request') {
              const prNumber = context.payload.pull_request.number;
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              
              const labels = pr.labels.map(l => l.name.toLowerCase());
              
              if (labels.includes('release')) {
                console.log(`Found 'release' label on PR #${pr.number}. Proceeding with release.`);
                core.setOutput('has_release_label', 'true');
              } else {
                console.log(`No 'release' label on PR #${pr.number}. Skipping release.`);
                console.log(`Current labels: ${labels.join(', ') || 'none'}`);
                core.setOutput('has_release_label', 'false');
              }
              return;
            }
            
            // For push events, find PR for this branch
            const currentRef = context.ref;
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${currentRef.replace('refs/heads/', '')}`,
              state: 'open'
            });
            
            if (prs.length === 0) {
              console.log('No open PR found for this branch. Skipping release.');
              core.setOutput('has_release_label', 'false');
              return;
            }
            
            const pr = prs[0];
            const labels = pr.labels.map(l => l.name.toLowerCase());
            
            if (labels.includes('release')) {
              console.log(`Found 'release' label on PR #${pr.number}. Proceeding with release.`);
              core.setOutput('has_release_label', 'true');
            } else {
              console.log(`No 'release' label on PR #${pr.number}. Skipping release.`);
              console.log(`Current labels: ${labels.join(', ') || 'none'}`);
              core.setOutput('has_release_label', 'false');
            }

  analyze-and-release:
    name: Analyze Commits & Create Release
    runs-on: ubuntu-latest
    needs: check-release-label
    if: needs.check-release-label.outputs.should_release == 'true'
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ inputs.bun-version }}

      - name: Install dependencies
        run: bun install

      - name: Get latest release SHA
        id: last-release
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 1
              });
              
              if (releases.length > 0) {
                const tagName = releases[0].tag_name;
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tagName}`
                });
                core.setOutput('sha', ref.object.sha);
                core.setOutput('tag', tagName);
                core.setOutput('version', tagName.replace(/^v/, '')); // Remove 'v' prefix if present
              } else {
                // No releases exist, use initial commit
                const { data: commits } = await github.rest.repos.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 1,
                  sha: 'HEAD'
                });
                if (commits.length > 0) {
                  // Get the first commit (oldest)
                  const allCommits = await github.paginate(github.rest.repos.listCommits, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    per_page: 100
                  });
                  const firstCommit = allCommits[allCommits.length - 1];
                  core.setOutput('sha', firstCommit.sha);
                  core.setOutput('version', '0.0.0');
                } else {
                  core.setOutput('sha', context.sha);
                  core.setOutput('version', '0.0.0');
                }
              }
            } catch (error) {
              core.setOutput('sha', context.sha);
              core.setOutput('version', '0.0.0');
            }

      - name: Get unreleased commits
        id: commits
        run: |
          LAST_SHA="${{ steps.last-release.outputs.sha }}"
          CURRENT_SHA="${{ github.sha }}"
          
          # Get all commits between last release and current SHA
          COMMITS_SIMPLE=$(git log ${LAST_SHA}..${CURRENT_SHA} --pretty=format:"%s%n%b" --no-merges)
          
          echo "commits_simple<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS_SIMPLE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Get code diff
        id: diff
        run: |
          LAST_SHA="${{ steps.last-release.outputs.sha }}"
          CURRENT_SHA="${{ github.sha }}"
          
          # Get file changes summary (what files changed)
          FILES_CHANGED=$(git diff --name-status ${LAST_SHA}..${CURRENT_SHA})
          
          # Get diff stats (how much changed per file)
          DIFF_STATS=$(git diff --stat ${LAST_SHA}..${CURRENT_SHA})
          
          # Get actual diff (limited to avoid huge output)
          # Exclude package-lock, bun.lock, and other lock files
          DIFF=$(git diff ${LAST_SHA}..${CURRENT_SHA} -- . ':(exclude)package-lock.json' ':(exclude)bun.lock' ':(exclude)yarn.lock' ':(exclude)pnpm-lock.yaml' | head -c 50000)
          
          echo "files_changed<<EOF" >> $GITHUB_OUTPUT
          echo "$FILES_CHANGED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "diff_stats<<EOF" >> $GITHUB_OUTPUT
          echo "$DIFF_STATS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "diff<<EOF" >> $GITHUB_OUTPUT
          echo "$DIFF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
            
      - name: AI Determine new release version
        id: ai-version
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          printf '%s\n' \
            "Analyze these git commits and code changes to determine the next semantic version number." \
            "" \
            "Current Version: ${{ steps.last-release.outputs.version }}" \
            "Last Release SHA: ${{ steps.last-release.outputs.sha }}" \
            "Current SHA: ${{ github.sha }}" \
            "" \
            "Commit messages:" \
            "${{ steps.commits.outputs.commits_simple }}" \
            "" \
            "Files changed:" \
            "${{ steps.diff.outputs.files_changed }}" \
            "" \
            "Diff stats:" \
            "${{ steps.diff.outputs.diff_stats }}" \
            "" \
            "Code changes (partial):" \
            "${{ steps.diff.outputs.diff }}" \
            "" \
            "Based on the actual code changes, determine what the most appropriate release type should be:" \
            "- BREAKING CHANGE or ! in commit OR breaking API changes in code = major version bump" \
            "- feat: prefix OR new features in code = minor version bump" \
            "- fix: or perf: prefix OR bug fixes in code = patch version bump" \
            "- No significant changes = no release needed" \
            "" \
            "X.Y.Z = the version number to release" \
            "Where X = Major release/breaking changes" \
            "Where Y = Minor release/new features" \
            "Where Z = Patch release/bug fixes" \
            "Respond with ONLY the version number in format X.Y.Z (e.g., 1.2.3) or \"none\" if no release is needed." \
            "Do not include any other text, explanation, or markdown formatting." > /tmp/version_prompt.txt
          
          PROMPT=$(cat /tmp/version_prompt.txt)
          
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{\"role\": \"user\", \"content\": $(echo "$PROMPT" | jq -Rs .)}],
              \"temperature\": 0.3
            }")
          
          AI_RESPONSE=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          echo "ai_response=$AI_RESPONSE" >> $GITHUB_OUTPUT

      - name: Parse AI version response
        id: parse-version
        run: |
          AI_RESPONSE="${{ steps.ai-version.outputs.ai_response }}"
          
          # Extract version number (X.Y.Z format) or check for "none"
          if echo "$AI_RESPONSE" | grep -qiE "none|skip|no release"; then
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "next_version=none" >> $GITHUB_OUTPUT
          else
            # Extract version number (format: X.Y.Z)
            NEXT_VERSION=$(echo "$AI_RESPONSE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            
            if [ -z "$NEXT_VERSION" ]; then
              echo "::error::AI did not return a valid version number. Response: $AI_RESPONSE"
              exit 1
            fi
            
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Apply prerelease tag
        id: final-version
        if: steps.parse-version.outputs.should_release == 'true'
        run: |
          BASE_VERSION="${{ steps.parse-version.outputs.next_version }}"
          
          if [ "${{ inputs.prerelease }}" == "true" ]; then
            # Append prerelease suffix (you can customize this)
            FINAL_VERSION="${BASE_VERSION}-rc.${GITHUB_RUN_NUMBER}"
            echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT
            echo "Creating prerelease: $FINAL_VERSION"
          else
            FINAL_VERSION="$BASE_VERSION"
            echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT
            echo "Creating release: $FINAL_VERSION"
          fi

      - name: Generate AI Release Notes
        id: ai-notes
        if: steps.parse-version.outputs.should_release == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          printf '%s\n' \
            "Generate a comprehensive release note in markdown format for the changes between two versions." \
            "" \
            "Current Version: ${{ steps.last-release.outputs.version }}" \
            "New Version: ${{ steps.final-version.outputs.final_version }}" \
            "Last Release SHA: ${{ steps.last-release.outputs.sha }}" \
            "Current SHA: ${{ github.sha }}" \
            "Service Name: ${{ inputs.service-name }}" \
            "" \
            "Commit messages:" \
            "${{ steps.commits.outputs.commits_simple }}" \
            "" \
            "Files changed:" \
            "${{ steps.diff.outputs.files_changed }}" \
            "" \
            "Diff stats:" \
            "${{ steps.diff.outputs.diff_stats }}" \
            "" \
            "Code changes (partial):" \
            "${{ steps.diff.outputs.diff }}" \
            "" \
            "Analyze BOTH the commit messages AND the actual code changes to create a well-formatted release note with:" \
            "- Summary of changes (based on actual code diff)" \
            "- Breaking changes (if any, check both commit messages and API changes in code)" \
            "- New features (feat: commits and new functionality in code)" \
            "- Bug fixes (fix: commits and bug fixes in code)" \
            "- Other improvements (perf:, refactor:, docs:, etc.)" \
            "" \
            "Use the code diff to provide specific, accurate details about what changed. Format the release notes professionally with proper markdown headings and bullet points. Make it user-friendly and easy to understand." > /tmp/notes_prompt.txt
          
          PROMPT=$(cat /tmp/notes_prompt.txt)
          
          RESPONSE=$(curl -s https://api.openai.com/v1/chat/completions \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -d "{
              \"model\": \"gpt-4\",
              \"messages\": [{\"role\": \"user\", \"content\": $(echo "$PROMPT" | jq -Rs .)}],
              \"temperature\": 0.7
            }")
          
          AI_NOTES=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
          echo "release_notes<<EOF" >> $GITHUB_OUTPUT
          echo "$AI_NOTES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Prepare release body
        id: release-body
        if: steps.parse-version.outputs.should_release == 'true'
        run: |
          AI_NOTES="${{ steps.ai-notes.outputs.release_notes }}"
          if [ -n "$AI_NOTES" ] && [ "$AI_NOTES" != "" ]; then
            echo "body<<EOF" >> $GITHUB_OUTPUT
            echo "$AI_NOTES" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "---" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "**Version:** ${{ steps.last-release.outputs.version }} → ${{ steps.final-version.outputs.final_version }}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "body<<EOF" >> $GITHUB_OUTPUT
            echo "## Release ${{ steps.final-version.outputs.final_version }}" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "**Version:** ${{ steps.last-release.outputs.version }} → ${{ steps.final-version.outputs.final_version }}" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "### Changes" >> $GITHUB_OUTPUT
            echo "\`\`\`" >> $GITHUB_OUTPUT
            echo "${{ steps.commits.outputs.commits_simple }}" >> $GITHUB_OUTPUT
            echo "\`\`\`" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Create GitHub Release
        if: steps.parse-version.outputs.should_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.final-version.outputs.final_version }}
          name: ${{ inputs.service-name }} v${{ steps.final-version.outputs.final_version }}
          body: ${{ steps.release-body.outputs.body }}
          draft: false
          prerelease: ${{ inputs.prerelease == 'true' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish:
    name: Publish to NPM
    runs-on: ubuntu-latest
    needs: analyze-and-release
    if: inputs.publish-npm == 'true' && inputs.prerelease != 'true'
    permissions:
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: ${{ inputs.bun-version }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: bun install

      - name: Build
        run: bun run build

      - name: Publish to npm
        run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
