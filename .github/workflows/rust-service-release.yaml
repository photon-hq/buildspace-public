name: Rust Binary Release with AI Notes

on:
  workflow_call:
    inputs:
      service-name:
        type: string
        required: true
        description: "The name of the service to release"
      binary-name:
        type: string
        required: true
        description: "The name of the binary to build (crate name)"
      binary-path:
        type: string
        required: false
        default: ""
        description: "Path to the crate if in a workspace (e.g., crates/client)"
      prerelease:
        type: string
        required: false
        default: "false"
        description: "Whether to create a prerelease"
      targets:
        type: string
        required: false
        default: "x86_64-unknown-linux-gnu,x86_64-apple-darwin,aarch64-apple-darwin,x86_64-pc-windows-msvc"
        description: "Comma-separated list of Rust targets to build"
    secrets:
      OPENAI_API_KEY:
        required: true
        description: "OpenAI API key for determining version and generating release notes"

jobs:
  check-release-label:
    name: Check for Release Label
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    outputs:
      should_release: ${{ steps.check-label.outputs.has_release_label }}
    steps:
      - name: Check for release label on PR
        id: check-label
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName === 'pull_request') {
              const prNumber = context.payload.pull_request.number;
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              const labels = pr.labels.map(l => l.name.toLowerCase());
              if (labels.includes('release')) {
                console.log(`Found 'release' label on PR #${pr.number}. Proceeding with release.`);
                core.setOutput('has_release_label', 'true');
              } else {
                console.log(`No 'release' label on PR #${pr.number}. Skipping release.`);
                core.setOutput('has_release_label', 'false');
              }
              return;
            }
            
            const currentRef = context.ref;
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${currentRef.replace('refs/heads/', '')}`,
              state: 'open'
            });
            
            if (prs.length === 0) {
              console.log('No open PR found for this branch. Skipping release.');
              core.setOutput('has_release_label', 'false');
              return;
            }
            
            const pr = prs[0];
            const labels = pr.labels.map(l => l.name.toLowerCase());
            if (labels.includes('release')) {
              console.log(`Found 'release' label on PR #${pr.number}. Proceeding with release.`);
              core.setOutput('has_release_label', 'true');
            } else {
              console.log(`No 'release' label on PR #${pr.number}. Skipping release.`);
              core.setOutput('has_release_label', 'false');
            }

  analyze-version:
    name: Analyze Commits & Determine Version
    runs-on: ubuntu-latest
    needs: check-release-label
    if: needs.check-release-label.outputs.should_release == 'true'
    permissions:
      contents: write
      pull-requests: read
    outputs:
      should_release: ${{ steps.parse-version.outputs.should_release }}
      version: ${{ steps.final-version.outputs.final_version }}
      release_notes: ${{ steps.ai-notes.outputs.final-message }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get latest release SHA
        id: last-release
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 1
              });
              
              if (releases.length > 0) {
                const tagName = releases[0].tag_name;
                const { data: ref } = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tagName}`
                });
                core.setOutput('sha', ref.object.sha);
                core.setOutput('version', tagName.replace(/^v/, ''));
              } else {
                const allCommits = await github.paginate(github.rest.repos.listCommits, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 100
                });
                const firstCommit = allCommits[allCommits.length - 1];
                core.setOutput('sha', firstCommit.sha);
                core.setOutput('version', '0.0.0');
              }
            } catch (error) {
              core.setOutput('sha', context.sha);
              core.setOutput('version', '0.0.0');
            }

      - name: AI Determine new release version
        id: ai-version
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: |
            Analyze commits and determine next semantic version.
            Current Version: ${{ steps.last-release.outputs.version }}
            Last Release SHA: ${{ steps.last-release.outputs.sha }}
            Current SHA: ${{ github.sha }}
            
            Rules:
            - BREAKING CHANGE or ! = major bump
            - feat: = minor bump
            - fix: or perf: = patch bump
            
            Respond with ONLY X.Y.Z or "none".

      - name: Parse AI version response
        id: parse-version
        run: |
          AI_RESPONSE="${{ steps.ai-version.outputs.final-message }}"
          if echo "$AI_RESPONSE" | grep -qiE "none|skip|no release"; then
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "next_version=none" >> $GITHUB_OUTPUT
          else
            NEXT_VERSION=$(echo "$AI_RESPONSE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            if [ -z "$NEXT_VERSION" ]; then
              echo "::error::AI did not return a valid version number. Response: $AI_RESPONSE"
              exit 1
            fi
            echo "should_release=true" >> $GITHUB_OUTPUT
            echo "next_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          fi

      - name: Apply prerelease tag
        id: final-version
        if: steps.parse-version.outputs.should_release == 'true'
        run: |
          BASE_VERSION="${{ steps.parse-version.outputs.next_version }}"
          if [ "${{ inputs.prerelease }}" == "true" ]; then
            FINAL_VERSION="${BASE_VERSION}-rc.${GITHUB_RUN_NUMBER}"
          else
            FINAL_VERSION="$BASE_VERSION"
          fi
          echo "final_version=$FINAL_VERSION" >> $GITHUB_OUTPUT

      - name: Generate AI Release Notes
        id: ai-notes
        if: steps.parse-version.outputs.should_release == 'true'
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: |
            Generate release notes in markdown. NO title. Start with content directly.
            
            Service: ${{ inputs.service-name }}
            Version: ${{ steps.last-release.outputs.version }} â†’ ${{ steps.final-version.outputs.final_version }}
            Current SHA: ${{ github.sha }}
            Last Release SHA: ${{ steps.last-release.outputs.sha }}
            
            REQUIREMENTS:
            1. NO title - Start directly with content
            2. Use plain language - Write like explaining to a friend
            3. Keep it SHORT - 1-2 sentences per item max
            4. Group logically - Use headers: ## New Features, ## Bug Fixes, ## Improvements
            5. Only include breaking changes if they exist
            6. NO commit SHA or diff sections
            7. Use emojis SPARINGLY - 1-2 total, prefer people emojis (ðŸ™‹â€â™€ï¸ðŸ™‹â€â™‚ï¸ðŸ‘‹)
            8. Be friendly and engaging

  build-binaries:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.os }}
    needs: analyze-version
    if: needs.analyze-version.outputs.should_release == 'true'
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
          - target: x86_64-apple-darwin
            os: macos-latest
          - target: aarch64-apple-darwin
            os: macos-latest
          - target: x86_64-pc-windows-msvc
            os: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-action@stable

      - name: Add target
        run: rustup target add ${{ matrix.target }}

      - name: Install dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libssl-dev pkg-config

      - name: Build binary
        run: |
          if [ -n "${{ inputs.binary-path }}" ]; then
            cargo build --release --target ${{ matrix.target }} -p ${{ inputs.binary-name }}
          else
            cargo build --release --target ${{ matrix.target }}
          fi
        shell: bash

      - name: Prepare artifact (Unix)
        if: matrix.os != 'windows-latest'
        run: |
          mkdir -p artifacts
          cp target/${{ matrix.target }}/release/${{ inputs.binary-name }} artifacts/${{ inputs.binary-name }}-${{ matrix.target }}
          chmod +x artifacts/${{ inputs.binary-name }}-${{ matrix.target }}

      - name: Prepare artifact (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          mkdir -p artifacts
          cp target/${{ matrix.target }}/release/${{ inputs.binary-name }}.exe artifacts/${{ inputs.binary-name }}-${{ matrix.target }}.exe
        shell: bash

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.binary-name }}-${{ matrix.target }}
          path: artifacts/*

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [analyze-version, build-binaries]
    if: needs.analyze-version.outputs.should_release == 'true'
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: Prepare release body
        id: release-body
        env:
          RELEASE_NOTES: ${{ needs.analyze-version.outputs.release_notes }}
          VERSION: ${{ needs.analyze-version.outputs.version }}
          BINARY_NAME: ${{ inputs.binary-name }}
        run: |
          # Write release notes from env var to avoid shell interpretation
          printf '%s\n' "$RELEASE_NOTES" > /tmp/body.txt
          echo "" >> /tmp/body.txt
          echo "---" >> /tmp/body.txt
          echo "" >> /tmp/body.txt
          echo "**Version:** $VERSION" >> /tmp/body.txt
          echo "" >> /tmp/body.txt
          echo "### Downloads" >> /tmp/body.txt
          echo "" >> /tmp/body.txt
          echo "| Platform | Download |" >> /tmp/body.txt
          echo "|----------|----------|" >> /tmp/body.txt
          echo "| Linux (x86_64) | \`${BINARY_NAME}-x86_64-unknown-linux-gnu\` |" >> /tmp/body.txt
          echo "| macOS (Intel) | \`${BINARY_NAME}-x86_64-apple-darwin\` |" >> /tmp/body.txt
          echo "| macOS (Apple Silicon) | \`${BINARY_NAME}-aarch64-apple-darwin\` |" >> /tmp/body.txt
          echo "| Windows | \`${BINARY_NAME}-x86_64-pc-windows-msvc.exe\` |" >> /tmp/body.txt
          
          {
            echo "body<<BODY_EOF"
            cat /tmp/body.txt
            echo "BODY_EOF"
          } >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.analyze-version.outputs.version }}
          name: ${{ inputs.service-name }} v${{ needs.analyze-version.outputs.version }}
          body: ${{ steps.release-body.outputs.body }}
          draft: false
          prerelease: ${{ inputs.prerelease == 'true' }}
          files: artifacts/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
